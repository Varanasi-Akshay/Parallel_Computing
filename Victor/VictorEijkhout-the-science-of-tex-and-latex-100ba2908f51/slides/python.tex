\documentclass{beamer}

\usepackage{beamerthemevictor,comment,verbatim}

\input{tutmacs}
\input{slidemacs}
\input idxmacs

\begin{document}

\title{Python}
\author{Victor Eijkhout}
\date{Notes for CS 594 -- Fall 2004}

\frame{\titlepage}

\section{Introduction}

\subsectionframe{The very basics}

\frame[containsverbatim]{
\frametitle{Running}
\begin{itemize}
\item Interactively: \n{python}
\item Call python: \n{python myfile.py}
\item Make executable: \n{chmod +x myfile.py}
\begin{verbatim}
file:
#!/usr/bin/python
...
\end{verbatim}
also \verb+#!/usr/bin/env python+
\end{itemize}

Use emacs: python mode
}

\frame{
\frametitle{Code layout}

Every statement on a line by itself: no semicolon needed.

With semicolon: more than one statement on a line.

Continuation by escaping line end.

Comments start with~\n{\#}.
}

\sectionframe{Data}
\subsection{Simple stuff}

\frame{
\frametitle{Numbers}
Booooring

\n{2/3} is zero; \n{1.*2/3} float
}

\frame{
\frametitle{Strings}

Strings in single or double quotes\\
otherwise largely like lists.

Concatenate: \n{'a'+"b"}

multiply \n{5*'word'}
}

\subsectionframe{Lists}

\frame{
\frametitle{The basics}
List: \n{a=[1,2,'a','bcd']}

List run from~0: \n{a[1:3]} is \n{[2,'a']}

Slices: \n{a[2:]}, \n{a[:3]}, \n{a[:]}\\
(that last one is a copy, as opposed to~\n{a}: copy of pointer)

Assign to slices: \n{a[2]=[3,4]}, \n{a[3:4]=[]}

Concatenate: \n{a+b[:3]}

Length: \n{len(a)}

Multidimensional: list of lists \n{a[3]=[4,5]}
}

\frame{
\frametitle{Other list manipulation}

\n{a.insert(i,x)} insert $x$ before element~$i$

\n{a.remove(x)} remove $x$; has to be present

\n{a.count(x)}, \n{a.index(x)} how many times present, where?

\n{a.append(x)}, \n{a.extend(L)} add at end of list
}

\frame{
\frametitle{Tips and tricks}

\begin{itemize}
\item A simple assignment \n{list1 = list2} does not create a second list:
it only copies a pointer. To create~\n{list1} as copy of~\n{list2},
do~\n{list1 = list2[:]}.
\item Create empty list: \n{a= n*[0]}
\end{itemize}
}

\sectionframe{Statements}

\frame[containsverbatim]{
\frametitle{White space}
White space is significant: in conditionals and loops and such, the
clauses are indented.
\begin{verbatim}
if a>0:
    do_something
    and more
else:
    yet more
\end{verbatim}
}

\frame[containsverbatim]{
\frametitle{Python support in emacs}
Indentation is done automatically
\begin{description}
\item[return] next line with proper indentation
\item[delete] to the previous indentation level
\item[tab] the the next level, but only if that is possible:
\begin{verbatim}
if a>0:
    do_something
    and more
after
\end{verbatim}
the \n{after} can be tabbed to belong in the conditional.
\end{description}
}

\subsectionframe{Control structures}

\frame[containsverbatim]{
\frametitle{Conditionals}
\begin{verbatim}
if a>0:
    print "yes"
elif b<0:
    print "no"
else:
    print "hm"
\end{verbatim}
Also
\begin{verbatim}
if a>0: print a
\end{verbatim}
}

\frame[containsverbatim]{
\frametitle{Loops}
\begin{verbatim}
for w in words:
    print w
\end{verbatim}
range over array elements. Numerical index:
\begin{verbatim}
for i in range(4):
    f(i)
\end{verbatim}
ranges over index array \n{[0,1,2,3]}.
Also \n{range(1,4)} is \n{[1,2,3]}; \n{range(4,1,-1)} is~\n{[4,3,2]}.
}

\frame[containsverbatim]{
\frametitle{While loop}
\begin{verbatim}
while p>0:
    p = prev[p]
\end{verbatim}

\n{break} and \n{continue} statements
}

\frame[containsverbatim]{
\frametitle{Functions}
Define
\begin{verbatim}
def fact(n):
    if n==0: return 1
    else:
        return n*fact(n-1)
\end{verbatim}
All variables local unless
\begin{verbatim}
    global x
\end{verbatim}
included
}

\subsection{Input/output}

\frame[containsverbatim]{
\frametitle{I/O}
Use \n{raw_input}; the \n{input} command evaluates its
input (which can be dangerous, since you can sneak system commands
in there).

Output with \n{print}. This automatically inserts a newline; prevent
that with \n{print,}. For precise control over spacing and newlines:
\begin{verbatim}
import sys
sys.stdout.write(<something>)
\end{verbatim}
This only works with strings: \n{str(23)} et cetera for conversion
}

\frame[containsverbatim]{
\frametitle{EOF}
\begin{verbatim}
try:
    a = raw_input()
    print "line:",a
except (EOFError):
    break
\end{verbatim}
}

\end{document}
